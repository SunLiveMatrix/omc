export type PromiseResolveCb<T> = (value: T | PromiseLike<T>) => void;
export type PromiseRejectCb = (reason?: any) => void;
export interface IDeferredPromise<T> {
    promise: Promise<T>;
    resolve: PromiseResolveCb<T>;
    reject: PromiseRejectCb;
}
/**
 * Creates a deferred Promise, where resolve/reject
 * are exposed to the place that holds the promise.
 *
 * Generally bad practice, but there are use-cases where one mixes
 * callback-based API with Promise API and this is helpful.
 */
export declare function deferred<T = void>(): IDeferredPromise<T>;
//# sourceMappingURL=deferred.d.ts.map