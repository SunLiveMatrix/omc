"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitFor = exports.retry = void 0;
const sleep_1 = require("./sleep");
const defaultOptions = {
    retries: 3,
    delay: 0,
    timeout: 0,
};
const envCanCaptureStack = !!Error.captureStackTrace;
/**
 * Executes provided `action` and returns its value.
 * If `action` throws or rejects, it will retry execution
 * several times before failing.
 *
 * @param action sync or async callback
 * @param options customize behavior
 */
async function retry(action, options) {
    const { retries, delay, timeout } = { ...defaultOptions, ...options };
    let lastError; // we expose last error if all attempts failed
    let timedOut = false;
    let timeoutId; // so we can cancel the timeout rejection
    let timeoutMessage = `timed out after ${timeout}ms`;
    if (envCanCaptureStack) {
        const stackProvider = { stack: '' };
        Error.captureStackTrace(stackProvider);
        timeoutMessage += `\n${stackProvider.stack}`;
    }
    const timeoutPromise = new Promise((_res, rej) => {
        if (timeout > 0) {
            timeoutId = setTimeout(() => {
                timedOut = true;
                if (!lastError) {
                    lastError = new Error(timeoutMessage);
                }
                rej();
            }, timeout);
        }
    });
    const maxAttempts = retries + 1;
    let attemptCount = 0;
    do {
        attemptCount++;
        try {
            const actionResult = action();
            if (actionResult instanceof Promise) {
                // make sure we always save error of original promise
                // Promise.race below might loose it due to timeout
                actionResult.catch((e) => (lastError = e || lastError));
            }
            const result = (await Promise.race([actionResult, timeoutPromise]));
            clearTimeout(timeoutId);
            return result;
        }
        catch (e) {
            lastError = e || lastError;
        }
        if (delay > 0) {
            try {
                await Promise.race([(0, sleep_1.sleep)(delay), timeoutPromise]);
            }
            catch {
                /* we throw lastError at the end */
            }
        }
    } while (!timedOut && attemptCount < maxAttempts);
    clearTimeout(timeoutId);
    throw lastError || new Error(`failed after ${attemptCount} tries`);
}
exports.retry = retry;
/**
 * @param options defaults to `{delay: 10, timeout: 1000, retries: Infinity }`
 */
function waitFor(action, options) {
    return retry(action, { delay: 10, timeout: 1000, retries: Infinity, ...options });
}
exports.waitFor = waitFor;
//# sourceMappingURL=retry.js.map