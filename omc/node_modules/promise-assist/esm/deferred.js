/**
 * Creates a deferred Promise, where resolve/reject
 * are exposed to the place that holds the promise.
 *
 * Generally bad practice, but there are use-cases where one mixes
 * callback-based API with Promise API and this is helpful.
 */
export function deferred() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    return { promise, resolve, reject };
}
//# sourceMappingURL=deferred.js.map